\documentclass[a4paper,12pt]{article}

% ==============================
%            ПАКЕТЫ
% ==============================
\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{pgfplots}
\pgfplotsset{compat=1.9}

% ==============================
%         ПЕРВЫЙ ЛИСТ
% ==============================

\author{Лиганкина Анна\\ Вариант 20}
\title{Лабораторная работа №4}
\date{\today}

\begin{document}

\maketitle
\tableofcontents

\newpage

% ==============================
%           ЗАДАНИЕ
% ==============================

\section{Задание}

Дан язык:
\[
    L = \text{\^{}} ((?\!\!: a|b)^*)c((?\!\!: a|b)^*)
    (?\!\!= \backslash 1 ab \backslash 2)\backslash 2 ba \backslash 1 \$
\]
Необходимо:
\begin{itemize}
    \item [--] проанализировать язык на КС-свойство, в случае его наличия - на 
    регулярность;

    \item [--] построить <<наивный>> парсер слов для языка, используя рекурсивный 
    разбор с возвратами (парсер не должен зацикливаться);

    \item [--] построить оптимизированный парсер слов для языка. Оценить сверху
    его вычислительную сложность;

    \item [--] посредством фазз-тестирования проверить эквивалентность парсеров
    и построить сравнительные графики их времени работы на случайных словах,
    принадлежащих языку и не принадлежащих языку (два тестовых пула).
\end{itemize}

% ==============================
%           ЯЗЫК
% ==============================

\section{Исследование языка}

Заметим, что исходный язык можно переписать в виде:
\[
    L =\{ w \;|\; w = xcyybax \;\&\; 
    x = (a|b)^* \;\&\; y = (a|b)^* \;\&\; xaby = ybax \}
\]
так как длина предпросмотра совпадает с длиной конца слова ($|\backslash 1 ab \backslash 2| = |\backslash 2 ba \backslash 1|$).

\subsection*{Доказательство, что язык не является КС}

Так как контекстно-свободные языки замкнуты относительно пересечения с регулярными
языками, то пересечем $L$ с $R = a^*ca^*ba^+$ и докажем, что получившийся язык
$L_R = L \cap R$ не КС.
\\\\
Слово $x$ однозначно определяется разделителем $c$ и состоит из букв $a$, либо
является пустым словом. Пусть $x = a^n, n \geq 0$. Так как в словах из $R$
содержится лишь одна буква $b$, то она соответствует букве $b$ из обязательного
блока $ba$, а значит, $y$ тоже состоит из букв $a$. Пусть $y = a^m, m \geq 0$.
\\\\
Рассмотрим условие $xaby = ybax$:
\[
    a^naba^m = a^mbaa^n
\]\[
    a^{n+1}ba^m = a^mba^{n+1} \Rightarrow m = n + 1
\]
Таким образом, язык $L_R$ выглядит так:
\[
    L = \{ w \;|\; w = a^nca^{2n+2} ba^{n+1} \;\&\; n \geq 0 \}
\]
По лемме о накачке (длина накачки $N$) рассмотрим слово $a^Nca^{2N+2}ba^{N+1}$ 
$\in L$:
\begin{itemize}
    \item если $|vxy| < N$ попадает в один из блоков из букв $a$, то нарушается 
    баланс с другими буквами $a$, и мы выходим из языка;

    \item если $|vxy| < N$ попадает на стык блоков букв $a$ и накачка задевает
    букву $c$ или букву $b$, то нарушается структура слова, где лишь одна буква
    $b$ и одна буква $c$, и мы выходим из языка;

    \item если $|vxy| < N$ попадает на стык блоков букв $a$ и мы качаем одновременно
    2 блока букв $a$ (3 не можем, так как $|vxy| < N$), то все равно рушится баланс
    с оставшимся блоком $a$, и мы выходим из языка.
\end{itemize}
Поэтому язык $L_R$ не является контекстно-свободным, а, следовательно, и язык $L$.

% ==============================
%       НАИВНЫЙ ПАРСЕР
% ==============================

\section{Наивный парсер}

Наивный парсер считывает и запоминает $x$ до символа $c$. Далее, он пытается 
рекурсивно <<угадать>> длину слова $y$. Запоминает $y$, а затем бежит по хвосту
слова и сравнивает его одновременно с $xaby$ и $ybax$. Если $y$ достиг конца слова,
то исходное слово не принадлежит языку. Таким образом, оценка сложности данного
парсера - $o(n^2)$, где $n$ - длина входного слова.

% ==============================
%    ОПТИМИЗИРОВАННЫЙ ПАРСЕР
% ==============================

\section{Оптимизированный парсер}

Оптимизация парсера происходит за счет следующего:
\begin{itemize}
    \item если длина слова четна, то слово автоматически не подходит языку;
    \item длина $y$ однозначно вычисляется по формуле <<(длина слова - 3)/2 - длина 
    $x$>>, благодаря чему алгоритмическая сложность парсера - $o(n)$, где $n$ - длина 
    входного слова;
    \item слова $x$ и $y$ являются палиндромами, а также $xaby$ и $ybax$, так как
    $xaby = ybax$.
\end{itemize}

\subsection*{Доказательство того, что если $xaby = ybax$, то $x, y$ и $xaby = ybax$ -
палиндромы.}

Докажем по индукции (по длине $|x| + |y|$).\\
\textbf{База индукции}. Пусть $x = \varepsilon$. Тогда $aby = yba \Rightarrow y \not
= \varepsilon$. Т.к. левая часть начинается с $a$, то $y = ay_1$. Тогда
\[
    abay_1 = ay_1ba \Rightarrow bay_1 = y_1ba
\]
Отсюда, либо $y_1 = \varepsilon$, либо $y_1$ начинается на $b$, т.е. $y_1 = by_2$
\[
    baby_2 = by_2ba \Rightarrow aby_2 = y_2ba
\]
Далее, $y_2 \not = \varepsilon$ и начинается на $a$, т.е. $y_2 = ay_3$ и т.д. 
Получаем, что $y = a(ba)^k, k \geq 0$ - палиндром.
\\
Аналогично, если $y = \varepsilon$, то $x = b(ab)^k, k \geq 0$ - палиндром.
\\
\textbf{Шаг индукции}. Пусть $x \not = \varepsilon$ и $y \not = \varepsilon$. Пусть
\[
    w = xaby = ybax
\]
Тогда более короткое слово из $x, y$ является префиксом другого (при этом $|x| \not =
|y|$, т.к. получится, что $ab = ba$). 2 случая:
\begin{enumerate}
    \item $|x| < |y|$. Тогда $x$ является префиксом $y$, т.е. $y = xy_1$, где $y_1
    \not = \varepsilon$.
    \[
        xabxy_1 = xy_1bax \Rightarrow abxy_1 = y_1bax
    \]
    А значит, $y_1$ начинается с $a$, т.е. $y_1 = ay_2$
    \[
        abxay_2 = ay_2bax \Rightarrow bxay_2 = y_2bax
    \]
    Здесь также 2 случая:
    \begin{enumerate}
        \item $y_2 = \varepsilon$. Тогда $y = xa$ и
        \[
            bxa = bax \Rightarrow xa = ax \Rightarrow x = a^n, y = a^{n+1},
        \]
        и $x, y$ - палиндромы; $w = a^naba^{n+1} = a^{n+1}baa^n = a^{n+1}ba^{n+1}$ -
        палиндром.

        \item $y_2 = by_3$. Тогда $y = xaby_3$ и
        \[
            bxaby_3 = by_3bax \Rightarrow xaby_3 = y_3bax
        \]
        Мы пришли к тому же уравнению вида $xaby = ybax$, но длина $|x| + |y_3|$
        уменьшилась $\Rightarrow$ по предположению индукции $x, y_3$ и $xaby_3 = 
        y_3bax$ - палиндромы. Отсюда $y = xaby_3$ - палиндром и 
        \[
            w^R = (xaby)^R = x^R (ab)^R y^R = (x = x^R, y = y^R) =  x ba y = w,
        \]
        т.е. $w$ - палиндром.        
    \end{enumerate}

    \item $|y| < |x|$ - симметричная ситуация. Тогда $y$ является префиксом $x$, т.е. 
    $x = yx_1$, где $x_1 \not = \varepsilon$. И 2 аналогичных исхода:
    \begin{enumerate}
        \item $x = b^{n+1}, y = b^n$ и $w = b^{n+1}abb^n = b^nbab^{n+1}$ - палиндромы.
        \item $x = ybax_3, y$ и $w$ - палиндромы.
    \end{enumerate}
\end{enumerate}
Таким образом, $x, y$ и $w$ - палиндромы.

% ==============================
%     ОЦЕНКА ЭФФЕКТИВНОСТИ
% ==============================

\section{Оценка эффективности}

\begin{tikzpicture}
\begin{axis}[
    width=12cm,
    height=5cm,
    scale only axis,
    xlabel={Длина строк},
    ylabel={Время (сек)},
    title = {Наивный парсер}
]
\addplot coordinates {
  (501, 0.297014) (1001, 3.359950) (1501, 14.351075) (2001, 23.183386) 
  (2501, 53.785615)
};
\addlegendentry{Слова $\in L$}
\addplot coordinates {
  (501, 0.102550) (1001, 1.360994) (1501, 6.673218) (2001, 10.487843) 
  (2501, 18.683635)
};
\addlegendentry{Слова $ \not \in L$}
\end{axis}
\end{tikzpicture}
\\
\begin{tikzpicture}
\begin{axis}[
    width=12cm,
    height=5cm,
    scale only axis,
    xlabel={Длина строк},
    ylabel={Время (сек)},
    title = {Оптимизированный парсер}
]
\addplot coordinates {
  (501, 0.000964) (1001, 0.003557) (1501, 0.007865) (2001, 0.020906) 
  (2501, 0.043663)
};
\addlegendentry{Слова $\in L$}
\addplot coordinates {
  (501, 0.000892) (1001, 0.002018) (1501, 0.006506) (2001, 0.010005) 
  (2501, 0.034420)
};
\addlegendentry{Слова $\not \in L$}
\end{axis}
\end{tikzpicture}
\end{document}